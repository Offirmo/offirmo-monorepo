import assert from 'tiny-invariant'
import { Temporal } from 'temporal-polyfill'
import type { Immutable } from '@offirmo-private/ts-types'

import {
	capitalizeâµ§first,
	remove_all_spaces,
} from '@offirmo-private/normalize-string'

import * as LooseDateLib from '../to-own/loose-dates/index.ts'
import type { State } from './types.ts'
import type { OrgId, PersonId } from '../types.ts'

/////////////////////////////////////////////////

const formatter_duration_narrow = new Intl.DurationFormat("en-us", { style: "narrow" });

/////////////////////////////////////////////////
// person

function getê“½name(state: Immutable<State>, id: PersonId | OrgId): string {
	const org = state.orgs[id]
	if (org) {
		return org.name || capitalizeâµ§first(org.id.slice(1))
	}

	const person = state.persons[id]
	assert(!!person, `get_name: no person with id ${id}!`)
	if (person.name)
		return person.name

	if (!person.id.includes('/'))
		return capitalizeâµ§first(person.id.slice(1))

	const [org_id, alias] = person.id.split('/')
	return capitalizeâµ§first(org_id!.slice(1)) + '/' + capitalizeâµ§first(alias!)
}

function getê“½one_linerâµ§person(state: Immutable<State>, id: PersonId): string {
	const person = state.persons[id]
	assert(person, `get_one_liner: no person with id ${id}!`)

	const age = (() => {
		const birth_dayâ€¿lda = person.dates['ðŸŽ‚']
		if (!birth_dayâ€¿lda)
			return undefined

		if (!birth_dayâ€¿lda.YYYY)
			return undefined // no way to know

		const birth_dayâ€¿temporal = Temporal.PlainDate.from(LooseDateLib.getê“½PlainDateIso(birth_dayâ€¿lda));
		const now = Temporal.Now.plainDateISO();
		const duration_y = now.since(birth_dayâ€¿temporal, {
			largestUnit: "years",
			smallestUnit: "years",
		});
		const duration_ym = now.since(birth_dayâ€¿temporal, {
			largestUnit: "years",
			smallestUnit: "months",
		});

		let result = birth_dayâ€¿lda.MM
			? remove_all_spaces(formatter_duration_narrow.format(duration_ym))
			: formatter_duration_narrow.format(duration_y) + 'o'

		return result
	})()

	return [
		//id : no need, the caller has it, can add if needed
		getê“½name(state, person.id),
		age,
		...person.known_nationalities
	].filter(s => !!s)
	.join(' ')
}

/////////////////////////////////////////////////
// personS

function getê“½all(state: Immutable<State>, { status = 'active' } = {}): Array<PersonId> {
	const ids = Object.keys(state.persons)
	return ids.filter(id => state.persons[id]!.status === status)
}

function getê“½family(state: Immutable<State>, { status = 'active' } = {}): Array<PersonId> {
	const person_ids = getê“½all(state, { status })
	const candidates = person_ids.filter(id => !id.includes('/'))
	return candidates
}

function getê“½familyâµ§close(state: Immutable<State>, { status = 'active' } = {}): Array<PersonId> {
	const candidates_ids = getê“½family(state, { status })
	// TODO how to filer?
	return candidates_ids
}

function getê“½partner(state: Immutable<State>): PersonId | undefined {
	const candidates_ids = getê“½familyâµ§close(state, { status: 'active' })
	// TODO how to filer?
	return candidates_ids[0]
}

/////////////////////////////////////////////////

export {
	getê“½one_linerâµ§person,

	getê“½all,
	getê“½family,
	getê“½familyâµ§close,
	getê“½partner,
}
