Adhoc questions on the application of Array, Stack, Queue, HashMap, TreeMap
algorithmic paradigm -- Backtracking
algorithmic paradigm -- Branch and bound
algorithmic paradigm -- Brute-force search
algorithmic paradigm -- Divide and conquer
algorithmic paradigm -- Dynamic programming
algorithmic paradigm -- Greedy algorithm
algorithmic paradigm -- Prune and search
algorithmic paradigm -- Recursion
algorithmic paradigm = https://en.wikipedia.org/wiki/Algorithmic_paradigm
antisymetric
Binary Search: Lower bound, Upper bound, Questions where binary search is not the obvious choice
BPE / Byte pair encoding https://github.com/openai/tiktoken
Cache-oblivious https://en.wikipedia.org/wiki/Cache-oblivious_algorithm
Communication-avoiding https://en.wikipedia.org/wiki/Communication-avoiding_algorithm
computational complexity -- Deletion time = time required for the update of the data structure when an input element is deleted;
computational complexity -- Initialization time = time required for the initial construction of the data structure;
computational complexity -- Insertion time = time required for the update of the data structure when one more input element is added;
computational complexity -- Other = operations specific to the problem in question
computational complexity -- Query time = time required to answer a query;
computational complexity -- Space = the amount of memory space required to store the data structure;
CRDT
Day–Stout–Warren = amortized binary tree balancing https://en.wikipedia.org/wiki/Day%E2%80%93Stout%E2%80%93Warren_algorithm
Disjoint set union
dynamic = ex. For an initial set of N numbers, dynamically maintain the maximal one when insertion and deletions are allowed.
dynamic programming
graph -- BFS https://en.wikipedia.org/wiki/Breadth-first_search
graph -- DFS
graph -- shortest path
graph -- shortest path -- A*
graph -- shortest path -- Djikstra https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
graph -- Topological sort
greedy https://en.wikipedia.org/wiki/Greedy_algorithm
hashing
hashing -- consistent hashing
hashing -- Extendible hashing, Consistent hashing https://en.wikipedia.org/wiki/Consistent_hashing
heap -- median in a stream
heap -- sliding window maximum
heap -- top k elements
heuristic https://en.wikipedia.org/wiki/Heuristic_(computer_science)
Huffman coding https://en.wikipedia.org/wiki/Huffman_coding
LLM -- temperature scaling
LLM output generation -- beam search = search algorithm used to generate output sequences from a model during inference https://ai-guide.future.mozilla.org/content/llms-101/
LLM output generation -- nucleus sampling aka. top-P sampling
LLM output generation -- sampling = search algorithm used to generate output sequences from a model during inference https://ai-guide.future.mozilla.org/content/llms-101/
Luleå algorithm https://en.wikipedia.org/wiki/Lule%C3%A5_algorithm
Markov Chains -- absorbing -- standard form
Markov Chains -- absorbing = only if absorbing state(s) and non-absorbing state(s) can end up in absorbing state(s)
Markov Chains -- absorbing state https://www.youtube.com/watch?v=bTeKu7WdbT8
Markov Chains -- limiting matrix
Markov Chains -- stationary distribution
Markov Chains -- transition matrix
Markov Chains https://www.youtube.com/watch?v=JHwyHIz6a8A
NP = Class of computational decision problems for which any given yes-solution can be verified as a solution in polynomial time by a deterministic Turing machine (or solvable by a non-deterministic Turing machine in polynomial time).
NP-complete = Class of decision problems which contains the hardest problems in NP. Each NP-complete problem has to be in NP.
NP-easy = At most as hard as NP, but not necessarily in NP.
NP-equivalent = Decision problems that are both NP-hard and NP-easy, but not necessarily in NP.
NP-hard = Class of problems which are at least as hard as the hardest problems in NP. Problems that are NP-hard do not have to be elements of NP; indeed, they may not even be decidable.
NP-hardness https://en.wikipedia.org/wiki/NP-hardness
NP-intermediate = If P and NP are different, then there exist decision problems in the region of NP that fall between P and the NP-complete problems. (If P and NP are the same class, then NP-intermediate problems do not exist because in this case every NP-complete problem would fall in P, and by definition, every problem in NP can be reduced to an NP-complete problem.)
reflexive
S3FIFO https://blog.jasony.me/system/cache/2023/08/01/s3fifo
search -- binary O(log n) = half-interval, logarithmic, binary chop, dichotomic https://en.wikipedia.org/wiki/Binary_search_algorithm
search -- exponential https://en.wikipedia.org/wiki/Exponential_search
search -- interpolation https://en.wikipedia.org/wiki/Interpolation_search
search -- linear O(n) = the worst
search -- ternary https://en.wikipedia.org/wiki/Ternary_search
search -- unary
Sliding window and 2 pointers based questions
sort -- alphadev https://www.nature.com/articles/s41586-023-06004-9
sort -- burstsort
sort -- radix sort O(nw) https://en.wikipedia.org/wiki/Radix_sort
sort -- topological = a graph traversal in which each node is visited only after all its dependencies are visited. (need DAG) https://en.wikipedia.org/wiki/Topological_sorting
sort https://en.wikipedia.org/wiki/Sorting_algorithm
strings: KMP, String sorting
Trabb Pardo-Knuth (TPK) https://en.wikipedia.org/wiki/TPK_algorithm
transitive
tree -- check if balanced
tree -- rotation https://en.wikipedia.org/wiki/Tree_rotation
tree -- search
tree -- trie -- prefix search
tree -- trie -- word search with counts
