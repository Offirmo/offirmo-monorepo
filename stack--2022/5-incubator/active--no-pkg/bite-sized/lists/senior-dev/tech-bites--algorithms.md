[ ] adhoc questions on the application of Array, Stack, Queue, HashMap, TreeMap
[ ] analysis of algorithms -- https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/
[ ] count bits
[ ] gcd -- greatest common divisor
+++ https://www.geeksforgeeks.org/courses/data-structures-and-algorithms-in-javascript
algorithmic paradigm -- Backtracking
algorithmic paradigm -- Branch and bound
algorithmic paradigm -- Brute-force search
algorithmic paradigm -- Divide and conquer
algorithmic paradigm -- Dynamic programming
algorithmic paradigm -- Greedy algorithm
algorithmic paradigm -- Prune and search
algorithmic paradigm -- Recursion
algorithmic paradigm = https://en.wikipedia.org/wiki/Algorithmic_paradigm
analysis of algorithms -- big O -- analysis 01 = Figure out what the input is and what n represents.
analysis of algorithms -- big O -- analysis 02 = Express the maximum number of operations, the algorithm performs in terms of n
analysis of algorithms -- big O -- analysis 03 = Eliminate all excluding the highest order terms
analysis of algorithms -- big O -- analysis 04 = Remove all the constant factors
analysis of algorithms -- big O -- analysis https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/
analysis of algorithms -- big O / asymptotic notation https://en.wikipedia.org/wiki/Big_O_notation#Infinite_asymptotics
analysis of algorithms -- big Oa -- O(1) = constant
analysis of algorithms -- big Ob -- O(n) = linear
analysis of algorithms -- big Oc -- O(log n) = logarithm
analysis of algorithms -- big Od -- O(n^2) = squared / quadratic
analysis of algorithms -- big Oe -- O(n^3) = cubic
analysis of algorithms -- big Of -- O(2^n) = exponential
analysis of algorithms -- big Og -- O(n!) = factorial
antisymetric
backtracking
Best, Average and Worst Cases
binary search: Lower bound, Upper bound, Questions where binary search is not the obvious choice
BPE / Byte pair encoding https://github.com/openai/tiktoken
Cache-oblivious https://en.wikipedia.org/wiki/Cache-oblivious_algorithm
Chocolate Distribution Problem
Communication-avoiding https://en.wikipedia.org/wiki/Communication-avoiding_algorithm
complexity chart https://flexiple.com/algorithms/big-o-notation-cheat-sheet
computational complexity -- Deletion time = time required for the update of the data structure when an input element is deleted;
computational complexity -- Initialization time = time required for the initial construction of the data structure;
computational complexity -- Insertion time = time required for the update of the data structure when one more input element is added;
computational complexity -- Other = operations specific to the problem in question
computational complexity -- Query time = time required to answer a query;
computational complexity -- Space = the amount of memory space required to store the data structure;
consensus -- raft https://en.wikipedia.org/wiki/Raft_(algorithm)  https://raft.github.io/
CRDT
Day–Stout–Warren = amortized binary tree balancing https://en.wikipedia.org/wiki/Day%E2%80%93Stout%E2%80%93Warren_algorithm
deque = double-ended queue
Disjoint set union
Disjoint set union
dynamic = ex. For an initial set of N numbers, dynamically maintain the maximal one when insertion and deletions are allowed.
dynamic programming
graph -- BFS https://en.wikipedia.org/wiki/Breadth-first_search
graph -- DFS
graph -- shortest path
graph -- shortest path -- A*
graph -- shortest path -- Djikstra https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
graph -- traversal -- topological sorting https://en.wikipedia.org/wiki/Topological_sorting
greedy https://en.wikipedia.org/wiki/Greedy_algorithm
hashing
hashing -- consistent hashing
hashing -- Extendible hashing, Consistent hashing https://en.wikipedia.org/wiki/Consistent_hashing
hcf
heap -- median in a stream
heap -- sliding window maximum
heap -- top k elements
heuristic https://en.wikipedia.org/wiki/Heuristic_(computer_science)
Huffman coding https://en.wikipedia.org/wiki/Huffman_coding
Josephus Problem
list -- floyd's cycle detection
LLM -- temperature scaling
LLM output generation -- beam search = search algorithm used to generate output sequences from a model during inference https://ai-guide.future.mozilla.org/content/llms-101/
LLM output generation -- nucleus sampling aka. top-P sampling
LLM output generation -- sampling = search algorithm used to generate output sequences from a model during inference https://ai-guide.future.mozilla.org/content/llms-101/
Luleå algorithm https://en.wikipedia.org/wiki/Lule%C3%A5_algorithm
MapReduce https://en.wikipedia.org/wiki/MapReduce
Markov Chains -- absorbing -- standard form
Markov Chains -- absorbing = only if absorbing state(s) and non-absorbing state(s) can end up in absorbing state(s)
Markov Chains -- absorbing state https://www.youtube.com/watch?v=bTeKu7WdbT8
Markov Chains -- limiting matrix
Markov Chains -- stationary distribution
Markov Chains -- transition matrix
Markov Chains https://www.youtube.com/watch?v=JHwyHIz6a8A
negamax https://en.wikipedia.org/wiki/Negamax
Order of Growth
P versus NP -- NP = "nondeterministic polynomial time" = quickly checkable (polynomially) = Class of computational decision problems for which any given yes-solution can be verified as a solution in polynomial time by a deterministic Turing machine (or solvable by a non-deterministic Turing machine in polynomial time)
P versus NP -- NP-complete = Class of decision problems which contains the hardest problems in NP. Each NP-complete problem has to be in NP. A fast solution to any one of the NP could be used to build a quick solution to any other problem in NP https://en.wikipedia.org/wiki/NP-complete
P versus NP -- NP-easy = At most as hard as NP, but not necessarily in NP.
P versus NP -- NP-equivalent = Decision problems that are both NP-hard and NP-easy, but not necessarily in NP.
P versus NP -- NP-hard = Class of problems which are at least as hard as the hardest problems in NP. Problems that are NP-hard do not have to be elements of NP; indeed, they may not even be decidable.
P versus NP -- NP-hardness https://en.wikipedia.org/wiki/NP-hardness
P versus NP -- NP-intermediate = If P and NP are different, then there exist decision problems in the region of NP that fall between P and the NP-complete problems. (If P and NP are the same class, then NP-intermediate problems do not exist because in this case every NP-complete problem would fall in P, and by definition, every problem in NP can be reduced to an NP-complete problem.)
P versus NP -- P = easily solvable (Polynomial time)
P versus NP https://en.wikipedia.org/wiki/P_versus_NP_problem
recursion -- tail
recursion -- tail call elimination
reflexive
S3FIFO https://blog.jasony.me/system/cache/2023/08/01/s3fifo
search -- binary O(log n) = half-interval, logarithmic, binary chop, dichotomic https://en.wikipedia.org/wiki/Binary_search_algorithm
search -- exponential https://en.wikipedia.org/wiki/Exponential_search
search -- interpolation https://en.wikipedia.org/wiki/Interpolation_search
search -- linear O(n) = the worst
search -- ternary https://en.wikipedia.org/wiki/Ternary_search
search -- unary
Sliding window and 2 pointers based questions
sort -- alphadev https://www.nature.com/articles/s41586-023-06004-9
sort -- bubble
sort -- burstsort
sort -- merge
sort -- quick
sort -- radix sort O(nw) https://en.wikipedia.org/wiki/Radix_sort
sort -- topological = a graph traversal in which each node is visited only after all its dependencies are visited. (need DAG) https://en.wikipedia.org/wiki/Topological_sorting
sort https://en.wikipedia.org/wiki/Sorting_algorithm
string -- pattern searching
strings: KMP, String sorting
Tower of Hanoi
Trabb Pardo-Knuth (TPK) https://en.wikipedia.org/wiki/TPK_algorithm
transitive
tree -- check if balanced
tree -- rotation https://en.wikipedia.org/wiki/Tree_rotation
tree -- search
tree -- trie -- prefix search
tree -- trie -- word search with counts
